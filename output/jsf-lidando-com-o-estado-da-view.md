---
title: "JSF - Lidando com o estado da view"
date: "2011-10-19"
author: "steppat"
authorEmail: "steppat@gmail.com"
main_guide: "main_guide"
main_category: "geral"
---

[JSF](http://www.jcp.org/en/jsr/detail?id=314  "especificação JSF 2 ") é um [framework web MVC](http://en.wikipedia.org/wiki/Web_application_framework "Definição de um web framework na wikipedia") que foi criado para desenvolver aplicações web de maneira **_stateful_** ([além de vários outros motivos](http://download.oracle.com/javaee/6/tutorial/doc/bnapj.html "Lista dos possíveis benefícios do JSF")). São os [componentes do JSF](http://www.ibm.com/developerworks/library/j-jsf1/ "Link para a série JSF for Nonbelievers da IBM") que guardam este estado e por causa deles JSF consegue se lembrar, por exemplo, qual [converter](http://download.oracle.com/javaee/6/tutorial/doc/bnast.html "Lista de converters JSF do Java EE Tutorial") ou [validator](http://download.oracle.com/javaee/6/tutorial/doc/bnatc.html "Lista de validators JSF do Java EE Tutorial") é [para usar](http://www.ibm.com/developerworks/java/library/j-jsf3/ "Artigo sobre Validation da seria JSF for nonbelievers da IBM"), ou qual era o valor que o usuário [digitou na requisição anterior](http://www.portalarquiteto.com.br/implementando-valuechangelistener-em-jsf/ "Artigo com dicas como implementar um ValueChangeListener").

O simples formulário abaixo declara um `[h:inputText](http://www.horstmann.com/corejsf/jsf-tags.html#Table4_7 "Documentação da tag")` e um `[h:commandButton](http://www.horstmann.com/corejsf/jsf-tags.html#Table4_15 "Documentação da tag")`. Quando o JSF recebe a requisição inicial (`HTTP GET`) serão instanciados esses componentes que são do tipo `[UIForm](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UIForm.html "Javadoc da classe")`, `[UIInput](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UIInput.html "Javadoc da classe")` (que é associado com um [validator](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/validator/package-summary.html "Lista de validators disponíveis") `[DoubleRangeValidator](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/validator/DoubleRangeValidator.html "Javadoc da classe")`) e um [`UICommand`](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UICommand.html "Javadoc da classe"). Cada componente estende a classe `[UIComponent](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UIComponent.html "Javadoc da classe")` e pode ter filhos, assim usando o famoso [design pattern](http://pt.wikipedia.org/wiki/Padr%C3%A3o_de_projeto_de_software "Link para wikipedia") _[Composite](http://pt.wikipedia.org/wiki/Padr%C3%A3o_de_projeto_de_software "Link para Wikipedia")_, veja o exemplo:

\[xml\] <h:form> <h:inputText value="#{formularioBean.valor}" id="valor"> <f:validateDoubleRange minimum="0" /> </h:inputText> <h:commandButton value="Enviar" action="#{formularioBean.mostra}"/> </h:form> \[/xml\]

[![](https://blog.caelum.com.br/wp-content/uploads/2011/10/component-tree-300x226.png "JSF Component tree")](https://blog.caelum.com.br/wp-content/uploads/2011/10/component-tree.png)O resultado é a **árvore de componentes** (também é chamado `view` ou `[UIViewRoot](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UIViewRoot.html "Javadoc da classe")`). Ela fica salva na `HttpSession` do usuário. Por isso, JSF sabe se lembrar qual valor (setter) deve ser usado para preencher o nosso modelo (é o componente que guarda isso!) e por isso também não é preciso definir na URI qual método deve ser chamado no bean, que é tão comum nos [frameworks action-based](http://vraptor.caelum.com.br/ "Link para o framework VRaptor que é action-based"). No formulário acima essa informação está encapsulado no `[UICommand](http://download.oracle.com/docs/cd/E17802_01/j2ee/javaee/javaserverfaces/2.0/docs/api/javax/faces/component/UICommand.html "Javadoc da classe")` (`h:commandButton`).

Cada vez que o controlador JSF recebe um novo `HTTP GET` para uma página (request inicial) será criado uma árvore nova. Para distinguir entre as árvores diferentes, JSF renderiza no HTML sempre um campo a mais que representa a **identificação da árvore** dentro da sessão HTTP:

\[xml\] <input id="javax.faces.ViewState" value="-5331242430046946924:4161480279607048884" type="hidden" /> \[/xml\]

`javax.faces.ViewState` guarda a identificação da árvore no lado do cliente e para cada `GET` se repete este procedimento (_nova árvore, nova identificação_). Ou seja, todas as página vão ter **uma ou mais árvores de componentes** na sessão (mesmo para uma aplicação com poucas páginas, o usuário poderia usar várias abas da mesma página). Para testar isso basta chamar uma página (`GET`) e verificar o número do campo `javax.faces.ViewState` (a identificação deve mudar):

1\. HTTP GET -> ViewState ID: 3695116712045768933 2. HTTP GET -> ViewState ID:-7330234494192939826 3. HTTP GET -> ViewState ID: 6490700310803488872 (3 requisições para a mesma página geram 3 árvores diferentes na sessão do usuário)

[![](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids-290x300.png "view-ids")](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids.png)Isso significa que um usuário mal intencionado poderia enviar milhares de GET para uma página JSF para causar a criação de árvores na sessão até a memória HEAP acabar. Para evitar esse tipo de problema, o controlador JSF **limita a quantidade de árvores** por usuário. Usando a implementação referencial [Mojarra](http://javaserverfaces.java.net/ "Site da implementação referencial do JSF") o padrão é de 15 árvores no máximo por sessão. Caso o usuário abra, por exemplo, mais do que 15 abas no navegador, o controlador JSF automaticamente vai tirar a árvore menos usada (LRU) da sessão. Para testar isso podemos usar um [filtro que imprime o conteúdo da sessão](https://gist.github.com/1286144 "Filtro simples para imprimir o conteúdo da sessão"), como mostra a imagem ao lado. Se o usuário usa uma aba com uma ID que o controlador já tirou recebemos a famosa `[ViewExpiredException](http://download.oracle.com/javaee/5/api/javax/faces/application/ViewExpiredException.html "Javadoc da exception")`:

Através de uma configuração no `web.xml`, específica para cada implementação JSF, podemos mudar o padrão. Segue a [definição para Mojarra](http://wikis.sun.com/display/GlassFish/JavaServerFacesRI#JavaServerFacesRI-Whatcontextparametersareavailableandwhatdotheydo%3F "Link com uma breve descrição dos context-params"):

\[xml\] <context-param> <param-name>com.sun.faces.numberOfViewsInSession</param-name> <param-value>5</param-value> </context-param> \[/xml\]

[![](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids2-300x163.png "view-ids2")](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids2.png)O parâmetro é específico para a implementação Mojarra e só funciona na versão 1.2. Mojarra 2.x não respeita o parâmetro apesar da [documentação](http://docs.jboss.org/jbossas/6/JSF_Guide/en-US/html/jsf.reference.html "Documentação do JBoss sobre JSF e Mojarra") indicar que ela sirva para ambas versões. A implementação MyFaces também possui [uma configuração parecida.](http://wiki.apache.org/myfaces/Performance "Link para a configuração do MyFaces")

Conseguimos então limitar a quantidade de árvores na sessão. Dependendo da quantidade de usuários e complexidade das telas comparado com o tamanho disponível de memória no servidor podemos mesmo assim enfrentar problemas. Por isso a especificação JSF oferece um recurso para **não gravar a árvore de componentes na sessão**. Mas onde fica o estado então? Toda árvore do componentes é serializada e é devolvida através de um `inputHidden` na resposta da requisição. Esse não é o comportamento padrão e deve ser configurado no `web.xml`, mas faz parte da especificação JSF:

\[xml\] <context-param> <param-name>javax.faces.STATE\_SAVING\_METHOD</param-name> <param-value>client</param-value> <!-- server é o padrão --> </context-param> \[/xml\]

Nesse caso não fica mais a identifição da árvore no HTML gerado, e sim **a árvore serializada**:

[![](https://blog.caelum.com.br/wp-content/uploads/2011/10/viewstateclient1.png "viewstate no lado do cliente")](https://blog.caelum.com.br/wp-content/uploads/2011/10/viewstateclient1.png)

Em cada requisição trafega a árvore inteira entre navegador e servidor e no início de cada requisição o servidor recria essa tela. Isso aumenta a banda e uso da CPU no servidor, mas diminui o uso da memória. É importante mencionar que apenas o `ViewState` será serializado (os componentes) e **não o estado da aplicação** (`ManagedBean`s). Caso colocarmos algum `ManagedBean` na sessão, o bean continua não sessão, não fazendo parte da serialização. O filtro mostra esse comportamento e continua imprimindo o `[FormularioBean](https://gist.github.com/1286181 "Implementação do FormularioBean")`:

[![](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids3-300x78.png "view-ids3")](https://blog.caelum.com.br/wp-content/uploads/2011/10/view-ids3.png)

A [documentação da Mojarra](http://wikis.sun.com/display/GlassFish/JavaServerFacesRI#JavaServerFacesRI-WhatarethedifferencesbetweenServerandClientsidestatesavingandwhatarethebenefits%2Fdrawbacksofeach%3F "Explicação entre client e server-state") indica que normalmente o `client-state` é a melhor solução, mas isso é um tradeoff entre desempenho e uso de memoria e deve ser avaliado para cada projeto. Mojarra até oferece soluções misturadas, podemos por exemplo serializar o `view-state`, mas deixar **a árvore serializada na sessão**.
