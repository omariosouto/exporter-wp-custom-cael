---
title: "10 razões para migrar sua aplicação para JSF 2"
date: "2012-09-19"
author: "lacerdaph"
authorEmail: "lacerdaph@gmail.com"
main_guide: "main_guide"
main_category: "geral"
---

Você [optou por um framework component based](https://blog.caelum.com.br/entenda-os-mvcs-e-os-frameworks-action-e-component-based/), escolheu trabalhar com JSF e ainda não sabe se deve encarar riscos e custos de migrar para a (não tão) nova versão da especificação? Vale a pena?

[![](https://blog.caelum.com.br/wp-content/uploads/2012/09/change-management1-300x225.jpeg "change-management1")](https://blog.caelum.com.br/wp-content/uploads/2012/09/change-management1.jpeg)

[JSF 2 surgiu](http://www.jcp.org/en/jsr/detail?id=314) em 10 de dezembro de 2009 fazendo [parte do JavaEE 6](http://www.oracle.com/technetwork/java/javaee/tech/index.html). Trouxe uma série de mudanças que todos já até cansaram de ouvir falar: [simplificação através de anotações, suporte a GET, Ajax Nativo](http://www.slideshare.net/andyschwartz/jsf-2-and-beyond-keeping-progress-coming), ViewScope, Facelets como renderizador padrão, [dentre muitas outras](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/). Após quase 3 anos da liberação da API, vale a pena mudar agora?

Eu e [Rafael Ponte](http://www.rponte.com.br/), um ativo participante da comunidade e conhecedor de JSF, enumeramos 10 razões que podem ajudar a sua decisão. Elas também valem se você estiver pensando em adotar um framework component based para um novo projeto.

1. **Desempenho**

JSF sempre foi considerado um framework com problemas graves de desempenho desde suas primeiras versões (RI 1.0/1.1). No entanto, após o lançamento do JSF1.2 [muitos dos problemas de performance foram resolvidos](http://javaserverfaces.java.net/nonav/rlnotes/1.2_14/releasenotes.html) graças ao talentoso time de desenvolvedores da Mojarra (RI). Mas ainda assim, devido a limitações de design na especificação do JSF1.2, o time de desenvolvedores sempre teve dificuldades para escrever código performático. Somente com a especificação do [JSF2](http://www.infoq.com/news/2012/01/jsf-update-2.x) é que tornou-se possível escrever código desde o ínicio com performance em mente.

A extensibilidade e as novas features (como [Partial State Saving](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/#state-saving), [Tree Visiting](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/#tree-visiting) e [Project Stage](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/#configuration-project-stage)) do JSF2 tem permitido [melhorias significantes de desempenho a cada release](http://lu4242.blogspot.com.br/2012/05/understandingjsf-2-and-wicket.html). Melhorias como o menor consumo de memória ([até 4x menos](http://programmers.stackexchange.com/questions/120760/is-jsf-really-ready-to-deliver-high-performance-web-applications)) e cpu, menor latência, melhor gerenciamento do estado de cada componente, otimização no algoritmo de busca de componentes e de [serialização da árvore de componentes](https://blog.caelum.com.br/jsf-lidando-com-o-estado-da-view/), [cache de EL expressions](https://cwiki.apache.org/MYFACES/cache-el-expressions.html) e outros.Indo mais além, é possível que o JSF2.2 (ou um futuro release) adote uma configuração que vá em direção contrária à natureza Stateful do framework, o [Stateless Mode](http://java.net/jira/browse/JAVASERVERFACES_SPEC_PUBLIC-1055). Com este modo stateless não haverá a necessidade de criar a árvore de componentes a cada request (teremos um cache de cada view), o que diminuirá o uso de memoria e cpu e [trará um ganho de até 30x no número de requisições por segundo](http://industrieit.com/blog/2011/11/stateless-jsf-high-performance-zero-per-request-memory-overhead/) em uma página complexa.

1. **Melhorias na Especificação**

[São muitos os pontos de melhoria](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/), mas gostaremos de ressaltar alguns, principalmente no que concerne à evolução/futuro da plataforma. Ficamos muito tempo parados no JSF1.2 e não vimos progresso na especificação. Contudo, parece que o jogo mudou. Alguns itens que ficaram em aberto no JSF2.0, como a falta de integração do `@ViewScope` com a combinação JSF + CDI, já estão previstos para serem resolvidos no [JSF2.2](http://jdevelopment.nl/jsf-22), assim como melhorias no suporte ao [HTML5](http://jdevelopment.nl/jsf-22/#html5), [AJAX](http://jdevelopment.nl/jsf-22/#ajax) e navegação com o [Faces Flow](http://jdevelopment.nl/jsf-22/#navigation) e outros [itens resolvidos](http://java.net/jira/secure/IssueNavigator.jspa?mode=hide&requestId=10884) já no [JSF2.1](http://javaserverfaces.java.net/nonav/rlnotes/2.1.4/whatsnew.html).

1. **Mais componentes!**

O número de componentes tem crescido a cada dia devido a facilidade de se implementar componentes no JSF2. Os principais conjuntos de componentes ([Primefaces](http://www.primefaces.org/showcase/ui/home.jsf), [Richfaces](http://showcase.richfaces.org/), [Trinidad](http://example.irian.at/trinidad-components-showcase/faces/pages/demoStart.xhtml) e [Icefaces](http://icefaces-showcase.icesoft.org/showcase.jsf?grp=aceMenu)) já possuem um excelente suporte a nova especificação e cada um deles possui diferentes sabores de componentes ricos para praticamente todos os tipos de aplicação. Devido a features como [Ajax Nativo](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/#ajax) e [Resource Loading](http://andyschwartz.wordpress.com/2009/07/31/whats-new-in-jsf-2/#resource-loading) estes mesmos conjuntos de componentes tornaram-se compatíveis, o que tem possibilitado [integrá-los sem muitas dificuldades](https://community.jboss.org/thread/176196) em um mesmo projeto - o que era quase impossível com JSF1.2.

Outro ponto interessante é que com o sucesso do JSF2 as empresas mantenedoras tem diminuído o suporte e a implementação de novos componentes JSF1.2, e, provavelmente, em médio prazo [será ainda mais raro obter correções e melhorias](http://in.relation.to/Bloggers/JSF20RoadmapForRichFaces) para esses componentes de forma gratuita.

1. **Adoção do Primefaces 2.x e 3.x**

No tópico anterior ressaltamos sobre a variedade de componentes, nesse ousamos afirmar que o [Primefaces](http://www.primefaces.org/) (2.x/3.x) está tão interessante que seu uso por si só já é um motivo para migrar. Eles sairam na frente do [RichFaces](http://www.jboss.org/richfaces) como implementação de componentes compatível com JSF 2. Só esse aspecto já seria o suficiente para ter uma adoção maior. Entretanto, o principal motivo foi a qualidade dos componentes. Comparando as [demos](http://www.primefaces.org/showcase-labs/ui/home.jsf) de [ambos](http://showcase.richfaces.org/) constate-se que o primeiro possui uma variedade muito maior de elementos, além de suporte com [componentes mobile](http://www.primefaces.org/showcase-labs/mobile/index.jsf). Ainda mais, ele usa o [ThemeRoller](http://jqueryui.com/themeroller/), facilitando a customização de acordo com sua necessidade.

Outro ponto que podemos citar é a [evolução](http://www.primefaces.org/whyprimefaces.html). Enquanto o Primefaces já está na 3.X (segunda geração compatível com JSF 2), o RichFaces ainda está na 4.X (primeira geração compatível com a tecnologia). [Você](http://kentorjava.com/2012/04/18/richfaces-and-primefaces-jsf-2-0/) pode [conferir](http://www.guj.com.br/java/219712-jsf-20---primefaces-x-richfaces) [diversas](http://stackoverflow.com/questions/6047860/primefaces-vs-icefaces-2-vs-richfaces) [comparações](http://www.guj.com.br/java/229089-richfacse-x-primefaces#1174845) que o pessoal no [mercado](http://www.mastertheboss.com/richfaces/primefaces-vs-richfaces-vs-icefaces) fez, [inclusive](http://www.coderanch.com/t/504459/JSF/java/Rich-Faces-VS-Prime-Faces) destacando alguns [pontos de desempenho](http://nlabrot.blogspot.com.br/2011/01/jsf2-components-frameworks-datatable.html), para [ajudar](http://mkblog.exadel.com/2011/02/why-go-with-richfaces/) em suas [conclusões](http://www.coderanch.com/t/551785/JSF/java/PrimeFaces-best-JSF-Component-Library).

1. **Maturidade**

[A adoção do JavaEE 6](https://blog.caelum.com.br/java-ee-versus-spring-retomando-a-discussao/) pode ser considerada um sucesso, fato esse pois [discussões antigas sobre JavaEE vs Spring](http://bill.burkecentral.com/2012/03/13/java-ee-wins-over-spring/) voltaram, e antigamente a especificação perdia fácil ([quem não se lembra](http://www.guj.com.br/java/114955-mundojava-edicao-33---ejb-3-vs-spring-uma-disputa-de-gigantes/2) daquela MundoJ - [EJB X Spring](http://www.guj.com.br/java/116301-ejb-versus-spring----materia-mundo-java)). Atualmente o Java EE tem uma boa relação com outros [frameworks, como o Spring](https://blog.caelum.com.br/spring-javaee-jsf/).

1. **Adoção do CDI**

[CDI é a especificação para Injeção de Dependência](https://blog.caelum.com.br/use-cdi-no-seu-proximo-projeto-java/) ([JSR-299](http://jcp.org/en/jsr/detail?id=299)). Surgiu também com o JavaEE 6 e foi [prontamente adotada](http://www.infoq.com/br/presentations/cdi-weld-seam-caelumdaybsb) pela comunidade, inclusive integrando com linguagens como Ruby (projeto [TorqueBox](http://torquebox.org/)). Já teve inclusive alguns estudos para [identificar o desempenho](http://hwellmann.blogspot.com/2010/11/cdi-major-risk-factor-in-java-ee-6.html) de aplicações que usam a API e concluem como a [implementação de referência Weld evoluiu](http://www.infoq.com/interviews/pete-muir-discusses-cdi-at-javaone-2011) e ainda tem a [evoluir](http://www.infoq.com/news/2011/02/muir_seam3). Com a especificação conseguimos algumas manipulações bem avançadas como, por exemplo, [injeção de dependência para objetos genéricos](https://blog.caelum.com.br/customizando-a-producao-de-dependencias-no-cdi/).

1. **Envolvimento da comunidade**

Há muito movimento ao redor do JSF2 e do CDI. Recentemente foi lançada pelo [Bauke Scholtz](http://balusc.blogspot.com.br/) (talvez o developer mais proeminente na plataforma) o [OmniFaces](http://balusc.blogspot.com.br/2012/07/omnifaces-11-is-released.html), que é uma biblioteca utilitária para consertar vários problemas que ainda não foram melhorados na especificação. Temos também outros projetos mainstream como o [Seam3](http://seamframework.org/Seam3), [CDISource](http://java.dzone.com/articles/announcing-cdisource) e [Apache CODI](https://cwiki.apache.org/EXTCDI/). Há um claro sombreamento de funcionalidades entre os projetos, porém a cooperação dos times está [tão grande que todos resolveram juntar forças em um só projeto, o DeltaSpike](http://www.infoq.com/news/2012/04/seam-deltaspike). O projeto agora é o foco da comunidade, e para comprovar isso, Pete Muir recentemente enviou um email na lista do seam-dev explicando que o projeto está a pleno vapor.

1. **Suporte ao HTML5**

Há muitas [funcionalidades interessantes na especificação](https://blog.caelum.com.br/websockets-html5-em-java-com-jetty-web-em-tempo-real/) e ver o [JSF tentar se alinhar](http://balusc.blogspot.com.br/2012/06/adding-html5-attributes-to-standard-jsf.html) mostra cada vez mais a preocupação da tecnologia em melhorar a [User Experience](https://blog.caelum.com.br/html-css-javascript-e-ux-na-nova-formacao-da-caelum/).

1. **Fim do suporte à versão antiga**

Aqui entra uma questão mais enterprise. Algumas empresas contratam Oracle, JBoss, IBM, justamente pelo suporte que elas oferecem aos seus produtos. Portanto, é importante [identificar a data de expiração desses serviços](http://www.online-seminars.net/files/datasheet/datasheet_weblogic11g.pdf). Uma outra preocupação é com relação a [variedade de implementações](http://www.oracle.com/technetwork/java/javaee/overview/compatibility-jsp-136984.html) para a especificação JavaEE. Alguns vendors demoraram a soltar os seus releases compatíveis, mas temos até alguns menos conhecidos que estão certificados, como [Apache Geronimo](http://geronimo.apache.org/) e [Caucho Resign](http://www.caucho.com/). Há também melhorias consideráveis de desempenho no [JBoss 7](https://blog.caelum.com.br/jboss-as-7-inovacao-nos-servidores-java-ee/) e [GlassFish 3.1](https://blogs.oracle.com/theaquarium/entry/glassfish_3_1_performance).

1. **Custos**

É um tópico complicado e possui uma série de variáveis envolvidas mudando para cada empresa. Entretanto, podemos citar alguns pontos relevantes a serem considerados, como se a sua empresa usa JSF 1.2 puro ou acoplado a algum outro framework como o Seam 2.x. Com a primeira opção, a [migração é fácil](http://stackoverflow.com/questions/4441713/migrating-from-jsf-1-2-to-jsf-2-0), e a quantidade e qualidade das novas funcionalidades que entraram na especificação [compensará todo este trabalho](http://martinfowler.com/bliki/DesignStaminaHypothesis.html). Em relação a segunda opção, está [saindo do forno o Seam 2.3](http://anonsvn.jboss.org/repos/seam/branches/community/Seam_2_3/seam-reference-guide/src/docbook/en-US/MigrationGuide.xml) que possui suporte ao JavaEE6. Entretanto, não sabemos ainda como será essa nova atualização.

Uma opção disponível é a combinação Seam3+JSF2+CDI, e as novas funcionalidades dessa união foram livremente inspiradas no que o Seam 2.x já provia.

Precisamos ainda considerar um outro ponto relevante: o sistema possui testes automatizados? [Unidade](https://blog.caelum.com.br/facilitando-seus-testes-de-unidade-no-java-um-pouco-de-mockito/), [Integração](https://blog.caelum.com.br/tdd-e-sua-influencia-no-acoplamento-e-coesao/) e principalmente [Sistema](https://blog.caelum.com.br/organizacao-de-testes-de-aceitacao-com-pageobjects/)? Caso negativo, seus custos podem ser bem mais altos do que você espera, pois descobrirá incompatibilidades e pequenos problemas de maneira inesperada.

[![](https://blog.caelum.com.br/wp-content/uploads/2012/09/migracao-300x168.jpeg "migracao")](https://blog.caelum.com.br/wp-content/uploads/2012/09/migracao.jpeg)

Abordamos aqui muitas das vantagens que você obterá ao encarar essa migração. [Dê os primeiros passos com JSF2](http://balusc.blogspot.com.br/2011/01/jsf-20-tutorial-with-eclipse-and.html) e sinta já a diferença. Muitos desses tópicos e outros [são discutidos no nosso curso de JSF](http://www.caelum.com.br/curso/fj-26-java-web-jsf2-cdi/). Uma outra forma de começar é [através do livro de JSF e JPA](http://www.casadocodigo.com.br/products/jsf-jpa) da Casa do Código.
