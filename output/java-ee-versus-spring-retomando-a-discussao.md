---
title: "Java EE versus Spring: retomando a discussão"
date: "2012-03-27"
author: "steppat"
authorEmail: "steppat@gmail.com"
main_guide: "main_guide"
main_category: "geral"
---

De [tempo](http://www.guj.com.br/java/60952-spring-ou-ejb-qual-usar) em [tempo](http://www.guj.com.br/java/114955-mundojava-edicao-33---ejb-3-vs-spring-uma-disputa-de-gigantes) surgem [artigos](http://www.theserverside.com/news/thread.tss?thread_id=63784) que retomam a velha disputa entre Spring e Java EE ([algumas vezes mais focado em EJBs](http://www.amazon.com/Expert-One-One-Development-without/dp/0764558315)). O [artigo mais recente](http://www.guj.com.br/java/267985-java-ee-versus-spring-a-visao-de-bill-burke "Noticia no GUJ sobre o artigo do Bill Burke") é do polêmico [Bill Burke](http://bill.burkecentral.com/2012/03/13/java-ee-wins-over-spring/ "Blog do Bill Burke") que já cutucou várias vezes, dando suas razões para justificar sua visão na qual o Spring morrerá e o Java EE ganhará a batalha.

Uma das principais promessas do [Java EE](http://www.oracle.com/technetwork/java/javaee/tech/index.html), como uma série de padrões definindos em especificações, [as JSRs](http://www.oracle.com/technetwork/java/javaee/tech/index.html "Lista dos JSRs"), é de dar liberdade em relação a fabricante (o _vendor lock-in_). Sua empresa teria então a possibilidade de escolher [a melhor implementação](http://www.oracle.com/technetwork/java/javaee/overview/compatibility-jsp-136984.html) (pelo critério de desempenho, documentação, suporte, extensões, etc.) sem ficar dependente de um único fabricante. Ao mesmo tempo, essas especificações nem sempre aparecem na velocidade desejada pelo mercado, a exemplo do Hibernate, que demorou mais de 6 anos até possuir uma especificação e aderir a ela, a JPA.

O Spring, por sua vez, apesar de ser [opensource](http://www.springsource.org/download), é mantido pelo [SpringSource](http://www.springsource.org/). Ele não segue um padrão como Java EE e só participa [esporadicamente nas especificações](http://jcp.org/en/jsr/summary?id=330). Tudo depende da vontade do SpringSource, e claro, do mercado e dos clientes do Spring. Ao mesmo tempo, pode evoluir com maior velocidade, sem precisar esperar a criação de especificações e nem aderir a elas. O [desentendimento](http://houseofhaug.wordpress.com/2005/08/12/hibernate-hates-spring/) entre SpringSource e principalmente os [desenvolvedores do JBoss](http://in.relation.to/2174.lace) já começou no Hibernate e aparece até dentro da [documentação do JBoss Seam](http://docs.jboss.com/seam/latest/reference/en-US/html/conversations.html), ambos iniciados pelo não menos polêmico [Gavin King](http://relation.to/Bloggers/Gavin).

**Sucesso do Spring e a ameaça ao antigo J2EE**

O Spring com Hibernate dentro de um servlet container se tornou uma [frequente alternativa ao EJB](http://blog.springsource.org/2007/11/09/a-response-to-ejb-3-and-spring-comparative-analysis/) e a outras especificações antigas do Java EE, época que ainda se usava o acrônimo J2EE, já [morto e enterrado](http://www.adam-bien.com/roller/abien/entry/j2ee_is_dead_completely_dead). Mais leve, flexível e embutível desde do inicio, baseando-se em [POJOs](http://martinfowler.com/bliki/POJO.html) [seguindo convenções](http://en.wikipedia.org/wiki/Convention_over_configuration), deixando configurações obsoletas, com muita [injeção de dependências](https://blog.caelum.com.br/singletons-e-static-perigo-a-vista/) e [baixo acoplamento](https://blog.caelum.com.br/facilitando-a-manutencao-dos-testes-ao-diminuir-o-acoplamento-com-o-codigo/) para não [interferir na testabilidade](https://blog.caelum.com.br/tdd-e-sua-influencia-no-acoplamento-e-coesao/). Diversos conceitos e recursos que o J2EE não aplicava e não possuia na época.

[![](https://blog.caelum.com.br/wp-content/uploads/2012/03/jobtrend-ejb-spring-300x166.png "Jobtrend EJB versus Spring")](https://blog.caelum.com.br/wp-content/uploads/2012/03/jobtrend-ejb-spring.png) Apesar de um container EJB oferecer muito mais serviços por padrão, o Spring é bastante flexível e sabe se integrar muito bem, inclusive pode ser utilizado dentro de  um servidor Java EE: pouco esforço é necessário para criar uma infra-estrutura parecida com a dos antigos EJBs. A burocracia e a [complexidade](https://blog.caelum.com.br/design-patterns-um-mau-sinal/) dos antigos EJBs, combinadas com um ambiente pesado e [uma série](http://blog.fragmental.com.br/2010/01/18/domain-driven-bolovo-passando-conhecimento-e-etc/) de [más práticas](http://martinfowler.com/bliki/AnemicDomainModel.html), fizeram muitas empresas e desenvolvedores se [afastarem do padrão](http://www.infoq.com/news/2008/02/ejb-spring-job-listings-trends).

Uma dos argumentos do Bill Burke é que Spring nunca foi uma alternativa por completo, pois sempre dependia de uma parte do Java EE. Isso é verdade, enfatizando talvez uma das principais missões do Spring: [não competetir com boas soluções do mercado](http://www.springsource.org/about). Sem dúvida existem especificações maduras dentro do Java EE, como JPA, JTA ou JSF. Spring pretende oferecer soluções próprias apenas quando não há uma boa alternativa. Exemplos disso são [Spring Security](http://static.springsource.org/spring-security/site/) (_alternativa poderosa ao JAAS_), [Spring MVC](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html) (_ausência de uma especificação MVC Action-based_), [Spring WebFlow](http://www.springsource.org/spring-web-flow) ou [Spring Integration](http://www.springsource.org/spring-integration) (_lightweight messaging_). Há, claro, exceções, com o Spring Web Services, que nunca conseguiu emplacar bem, sendo um dos motivos o sucesso e facilidade do JAX-WS.

**CDI e Java EE 6: uma grande mudança**

O [sucesso do Spring](http://blog.springsource.com/2008/01/23/spring-overtakes-ejb-as-a-skills-requirement/) pressionou enormemente o Java EE (JCP em geral) que primeiro respondeu com o [EJB 3.0](http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html) introduzindo mudanças radicais como o uso da JPA em vez dos [Entity Beans CMP](http://java.sun.com/developer/technicalArticles/ebeans/EJB20CMP/), mas isso não foi suficiente. [Java EE 6](http://jcp.org/en/jsr/detail?id=316) foi outra resposta com várias atualizações como [JSF 2.0](http://www.caelum.com.br/curso/fj-26-java-web-jsf2-cdi/), [EJB 3.1](https://blog.caelum.com.br/novidades-do-ejb-31-do-futuro-java-ee-6/), [Bean Validation](https://blog.caelum.com.br/java-ee-6-comecando-com-bean-validation/) e [CDI](https://blog.caelum.com.br/customizando-a-producao-de-dependencias-no-cdi/). Muitas dessas especificações foram inspiradas no sucesso do [JBoss Seam](http://www.caelum.com.br/curso/fj-34-desenvolvimento-web-agil-jboss-seam/), trazendo anotações, convenções e descomplicações que faltavam a plataforma há muito tempo. A nova especificação CDI trouxe um modelo de componentes mais leve se comparado ao EJB, e até mesmo ao Spring, e usando funcionalidades atuais da linguagem Java como anotações e generics. CDI é a cola que faltou para juntar as especificações dentro do Java EE, [atacando diretamente o terreno do Spring IoC](http://cdisource.org/site/2011/06/spring-and-java-ee-6-cdi-get-it-done/). Os [EJBs perderam espaço no mercado](http://developers-blog.org/blog/default/2010/02/24/Trend-between-Spring-and-EJB-job-requirements), mas o Java EE em geral volta a ganhar força trazendo mais produtividade e cada vez mais possibilidades de utilizar cada tecnologia separadamente, ou agrupá-las facilmente através do CDI.

**CDI significa o fim do Spring?**

Sem dúvida CDI tapou vários buracos dentro Java EE. Ficou muito [mais simples](https://cwiki.apache.org/confluence/display/EXTCDI/JPA+Overview), além disso, há [novos servidores](http://openejb.apache.org/apache-tomee.html) disponíveis, [flexíveis](https://blog.caelum.com.br/jboss-as-7-inovacao-nos-servidores-java-ee/) e [leves](http://glassfish.java.net/). Muitos dos argumentos a favor do Spring não existem mais, além de que, por ter sido originalmente concebido para trabalhar com as configurações via XML, as anotações não se aplicam de maneira tão fácil e sucinta como com o CDI. Utilizando as especificações Java EE você recebe uma plataforma bastante completa para resolver muitos problemas, sem aquele risco antigo de overengineering. Lembrando que você pode (e deve!) utilizar apenas as que se enquadram na sua aplicação.

Mas nossas ferramentas estão em constante transformação. Existem novos desafios como [NoSQL](https://blog.caelum.com.br/bancos-de-dados-nao-relacionais-e-o-movimento-nosql/) e [cloud](http://opentour.cloudfoundry.com/):  tópicos que o [Java EE (ainda) não cobre](http://www.oraclejavamagazine-digital.com/javamagazine/20120102?sub_id=A6RrQLYUF8CD&folio=26#pg27). Nesse terreno o Spring continua se [destacando](http://www.springsource.org/spring-data) sendo um [diferencial](http://www.springsource.org/spring-social), e claro, continua fazendo um bom trabalho na integração de frameworks e bibliotecas.

**Qual será o caminho do Java EE?**

No primeiro semestre de 2013 deve sair o [Java EE 7](http://www.infoq.com/articles/javaee7-cloud-support)  focando [na nuvem](PaaS: http://java.net/downloads/javaee-spec/PaaS.pdf) e com mais simplificações, [atualizando várias especificações](http://www.infoq.com/br/news/2012/01/javaEE7-novidades), por exemplo [JMS 2.0](http://java.net/projects/jms-spec/pages/JSR343EarlyDraft), [JAX-RS 2.0](http://marek.potociar.net/2011/11/17/on-jax-rs-2-0-from-devoxx/) ou uma [nova JSON API](http://jcp.org/en/jsr/detail?id=353). O JCP acelerou e [renovou](http://jcp.org/en/jsr/detail?id=348) depois do [apagão da Sun](http://www.guj.com.br/java/124319-bomba---oracle-compra-a-sun) mesmo após ter enfrentado [dificuldades com a comunidade](https://blogs.apache.org/foundation/entry/the_asf_resigns_from_the). Há ainda pontos sem muitas respostas: qual é a alternativa action based no Java EE? O JSF, mesmo com os esforços recentes, fica a desejar para trabalhar com websites dado os desafios atuais em relação a tamanho de dados trafegados, fine tuning de html e javascript e a apresentação mobile. Os desenvolvedores acabam aplicando JSF em pontos duvidosos, gerando páginas com megabytes de html e javascript que impactam negativamente qualquer site web. O Spring MVC aparece como alternativa e ganha adeptos. JAX-RS + CDI pode ser uma resposta, mas ainda há bastante a evoluir.

E você? Qual plataforma adotará nos seus próximos projetos? Para qual caminho acredita que elas estejam andando?
